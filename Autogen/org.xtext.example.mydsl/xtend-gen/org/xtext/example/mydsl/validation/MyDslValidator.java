/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import ConfiguratorPackage.Assignment;
import ConfiguratorPackage.BinaryConstraint;
import ConfiguratorPackage.BinaryOperators;
import ConfiguratorPackage.BooleanValue;
import ConfiguratorPackage.Configuration;
import ConfiguratorPackage.Expression;
import ConfiguratorPackage.IntegerValue;
import ConfiguratorPackage.NamedElement;
import ConfiguratorPackage.Parameter;
import ConfiguratorPackage.Root;
import ConfiguratorPackage.Set;
import ConfiguratorPackage.StringValue;
import ConfiguratorPackage.TypeEnum;
import ConfiguratorPackage.UnaryConstraint;
import ConfiguratorPackage.Value;
import com.google.common.base.Objects;
import java.util.HashMap;
import java.util.HashSet;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.Functions.Function2;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  protected static boolean _constraint(final NamedElement it) {
    boolean _and = false;
    String _name = it.getName();
    boolean _notEquals = (!Objects.equal(_name, null));
    if (!_notEquals) {
      _and = false;
    } else {
      String _name_1 = it.getName();
      boolean _isEmpty = _name_1.isEmpty();
      boolean _not = (!_isEmpty);
      _and = _not;
    }
    return _and;
  }
  
  /**
   * Check for unique parameters in the root element.
   * If the sizes of the params and unique params are not the same
   * we have duplicate entries
   */
  protected static boolean _constraintParams(final Root it) {
    boolean _xblockexpression = false;
    {
      EList<Expression> _expressions = it.getExpressions();
      final Function1<Expression, Boolean> _function = new Function1<Expression, Boolean>() {
        public Boolean apply(final Expression e) {
          return Boolean.valueOf((e instanceof Parameter));
        }
      };
      final Iterable<Expression> params = IterableExtensions.<Expression>filter(_expressions, _function);
      HashSet<String> _hashSet = new HashSet<String>();
      final Function2<HashSet<String>, Expression, HashSet<String>> _function_1 = new Function2<HashSet<String>, Expression, HashSet<String>>() {
        public HashSet<String> apply(final HashSet<String> s, final Expression e) {
          HashSet<String> _xblockexpression = null;
          {
            String _name = e.getName();
            s.add(_name);
            _xblockexpression = s;
          }
          return _xblockexpression;
        }
      };
      final HashSet<String> uniqueParams = IterableExtensions.<Expression, HashSet<String>>fold(params, _hashSet, _function_1);
      int _size = IterableExtensions.size(params);
      int _size_1 = uniqueParams.size();
      _xblockexpression = (_size == _size_1);
    }
    return _xblockexpression;
  }
  
  /**
   * Check that the value of each assignment has the correct type according to the assigned type of the parameter
   */
  protected static boolean _constraintAssignment(final Root it) {
    boolean _xblockexpression = false;
    {
      EList<Expression> _expressions = it.getExpressions();
      final Function1<Expression, Boolean> _function = new Function1<Expression, Boolean>() {
        public Boolean apply(final Expression e) {
          return Boolean.valueOf((e instanceof Parameter));
        }
      };
      final Iterable<Expression> params = IterableExtensions.<Expression>filter(_expressions, _function);
      HashMap<String, TypeEnum> _hashMap = new HashMap<String, TypeEnum>();
      final Function2<HashMap<String, TypeEnum>, Expression, HashMap<String, TypeEnum>> _function_1 = new Function2<HashMap<String, TypeEnum>, Expression, HashMap<String, TypeEnum>>() {
        public HashMap<String, TypeEnum> apply(final HashMap<String, TypeEnum> m, final Expression e) {
          HashMap<String, TypeEnum> _xblockexpression = null;
          {
            final Parameter p = ((Parameter) e);
            String _name = p.getName();
            TypeEnum _type = p.getType();
            m.put(_name, _type);
            _xblockexpression = m;
          }
          return _xblockexpression;
        }
      };
      final HashMap<String, TypeEnum> typeMap = IterableExtensions.<Expression, HashMap<String, TypeEnum>>fold(params, _hashMap, _function_1);
      EList<Configuration> _configurators = it.getConfigurators();
      final Function1<Configuration, Boolean> _function_2 = new Function1<Configuration, Boolean>() {
        public Boolean apply(final Configuration c) {
          boolean _xblockexpression = false;
          {
            EList<Assignment> _assignments = c.getAssignments();
            final Function1<Assignment, Boolean> _function = new Function1<Assignment, Boolean>() {
              public Boolean apply(final Assignment a) {
                return Boolean.valueOf((a instanceof StringValue));
              }
            };
            final Iterable<Assignment> strings = IterableExtensions.<Assignment>filter(_assignments, _function);
            EList<Assignment> _assignments_1 = c.getAssignments();
            final Function1<Assignment, Boolean> _function_1 = new Function1<Assignment, Boolean>() {
              public Boolean apply(final Assignment a) {
                return Boolean.valueOf((a instanceof IntegerValue));
              }
            };
            final Iterable<Assignment> integers = IterableExtensions.<Assignment>filter(_assignments_1, _function_1);
            EList<Assignment> _assignments_2 = c.getAssignments();
            final Function1<Assignment, Boolean> _function_2 = new Function1<Assignment, Boolean>() {
              public Boolean apply(final Assignment a) {
                return Boolean.valueOf((a instanceof BooleanValue));
              }
            };
            final Iterable<Assignment> booleans = IterableExtensions.<Assignment>filter(_assignments_2, _function_2);
            final Function2<Boolean, Assignment, Boolean> _function_3 = new Function2<Boolean, Assignment, Boolean>() {
              public Boolean apply(final Boolean b, final Assignment a) {
                boolean _and = false;
                if (!(b).booleanValue()) {
                  _and = false;
                } else {
                  Parameter _parameter = a.getParameter();
                  String _name = _parameter.getName();
                  TypeEnum _get = typeMap.get(_name);
                  boolean _equals = _get.equals(TypeEnum.STRING_TYPE);
                  _and = _equals;
                }
                return Boolean.valueOf(_and);
              }
            };
            final Boolean stringsSatisfied = IterableExtensions.<Assignment, Boolean>fold(strings, Boolean.valueOf(true), _function_3);
            final Function2<Boolean, Assignment, Boolean> _function_4 = new Function2<Boolean, Assignment, Boolean>() {
              public Boolean apply(final Boolean b, final Assignment a) {
                boolean _and = false;
                if (!(b).booleanValue()) {
                  _and = false;
                } else {
                  Parameter _parameter = a.getParameter();
                  String _name = _parameter.getName();
                  TypeEnum _get = typeMap.get(_name);
                  boolean _equals = _get.equals(TypeEnum.INTEGER_TYPE);
                  _and = _equals;
                }
                return Boolean.valueOf(_and);
              }
            };
            final Boolean integersSatisfied = IterableExtensions.<Assignment, Boolean>fold(integers, Boolean.valueOf(true), _function_4);
            final Function2<Boolean, Assignment, Boolean> _function_5 = new Function2<Boolean, Assignment, Boolean>() {
              public Boolean apply(final Boolean b, final Assignment a) {
                boolean _and = false;
                if (!(b).booleanValue()) {
                  _and = false;
                } else {
                  Parameter _parameter = a.getParameter();
                  String _name = _parameter.getName();
                  TypeEnum _get = typeMap.get(_name);
                  boolean _equals = _get.equals(TypeEnum.BOOLEAN_TYPE);
                  _and = _equals;
                }
                return Boolean.valueOf(_and);
              }
            };
            final Boolean booleansSatisfied = IterableExtensions.<Assignment, Boolean>fold(booleans, Boolean.valueOf(true), _function_5);
            boolean _and = false;
            if (!((stringsSatisfied).booleanValue() && (integersSatisfied).booleanValue())) {
              _and = false;
            } else {
              _and = (booleansSatisfied).booleanValue();
            }
            _xblockexpression = _and;
          }
          return Boolean.valueOf(_xblockexpression);
        }
      };
      _xblockexpression = IterableExtensions.<Configuration>forall(_configurators, _function_2);
    }
    return _xblockexpression;
  }
  
  /**
   * Check for unique parameters in a given configuration
   */
  protected static boolean _constraintOneAssignmentPerParameter(final Configuration it) {
    boolean _xblockexpression = false;
    {
      EList<Assignment> _assignments = it.getAssignments();
      HashSet<String> _hashSet = new HashSet<String>();
      final Function2<HashSet<String>, Assignment, HashSet<String>> _function = new Function2<HashSet<String>, Assignment, HashSet<String>>() {
        public HashSet<String> apply(final HashSet<String> s, final Assignment a) {
          HashSet<String> _xblockexpression = null;
          {
            Parameter _parameter = a.getParameter();
            String _name = _parameter.getName();
            s.add(_name);
            _xblockexpression = s;
          }
          return _xblockexpression;
        }
      };
      final HashSet<String> uniqueParams = IterableExtensions.<Assignment, HashSet<String>>fold(_assignments, _hashSet, _function);
      int _size = uniqueParams.size();
      EList<Assignment> _assignments_1 = it.getAssignments();
      int _size_1 = _assignments_1.size();
      _xblockexpression = (_size == _size_1);
    }
    return _xblockexpression;
  }
  
  /**
   * Check that the types of BinaryConstraints are good
   */
  protected static boolean _constraintBinary(final BinaryConstraint it) {
    boolean _switchResult = false;
    BinaryOperators _operator = it.getOperator();
    if (_operator != null) {
      switch (_operator) {
        case ADDITION:
          boolean _and = false;
          Expression _left = it.getLeft();
          Value _valueResolver = MyDslValidator.valueResolver(_left);
          if (!(_valueResolver instanceof IntegerValue)) {
            _and = false;
          } else {
            Expression _right = it.getRight();
            Value _valueResolver_1 = MyDslValidator.valueResolver(_right);
            _and = (_valueResolver_1 instanceof IntegerValue);
          }
          _switchResult = _and;
          break;
        case AND:
          boolean _and_1 = false;
          Expression _left_1 = it.getLeft();
          Value _valueResolver_2 = MyDslValidator.valueResolver(_left_1);
          if (!(_valueResolver_2 instanceof BooleanValue)) {
            _and_1 = false;
          } else {
            Expression _right_1 = it.getRight();
            Value _valueResolver_3 = MyDslValidator.valueResolver(_right_1);
            _and_1 = (_valueResolver_3 instanceof BooleanValue);
          }
          _switchResult = _and_1;
          break;
        case EQUAL:
          Expression _left_2 = it.getLeft();
          Value _valueResolver_4 = MyDslValidator.valueResolver(_left_2);
          Expression _right_2 = it.getRight();
          Value _valueResolver_5 = MyDslValidator.valueResolver(_right_2);
          _switchResult = _valueResolver_4.equals(_valueResolver_5);
          break;
        case GREATER:
          boolean _and_2 = false;
          Expression _left_3 = it.getLeft();
          Value _valueResolver_6 = MyDslValidator.valueResolver(_left_3);
          if (!(_valueResolver_6 instanceof IntegerValue)) {
            _and_2 = false;
          } else {
            Expression _right_3 = it.getRight();
            Value _valueResolver_7 = MyDslValidator.valueResolver(_right_3);
            _and_2 = (_valueResolver_7 instanceof IntegerValue);
          }
          _switchResult = _and_2;
          break;
        case LESS:
          boolean _and_3 = false;
          Expression _left_4 = it.getLeft();
          Value _valueResolver_8 = MyDslValidator.valueResolver(_left_4);
          if (!(_valueResolver_8 instanceof IntegerValue)) {
            _and_3 = false;
          } else {
            Expression _right_4 = it.getRight();
            Value _valueResolver_9 = MyDslValidator.valueResolver(_right_4);
            _and_3 = (_valueResolver_9 instanceof IntegerValue);
          }
          _switchResult = _and_3;
          break;
        case MULTIPLICATION:
          boolean _and_4 = false;
          Expression _left_5 = it.getLeft();
          Value _valueResolver_10 = MyDslValidator.valueResolver(_left_5);
          if (!(_valueResolver_10 instanceof IntegerValue)) {
            _and_4 = false;
          } else {
            Expression _right_5 = it.getRight();
            Value _valueResolver_11 = MyDslValidator.valueResolver(_right_5);
            _and_4 = (_valueResolver_11 instanceof IntegerValue);
          }
          _switchResult = _and_4;
          break;
        case OR:
          Expression _left_6 = it.getLeft();
          Value _valueResolver_12 = MyDslValidator.valueResolver(_left_6);
          Expression _right_6 = it.getRight();
          Value _valueResolver_13 = MyDslValidator.valueResolver(_right_6);
          _switchResult = _valueResolver_12.equals(_valueResolver_13);
          break;
        case SUBSET:
          Expression _left_7 = it.getLeft();
          Value _valueResolver_14 = MyDslValidator.valueResolver(_left_7);
          Expression _right_7 = it.getRight();
          Value _valueResolver_15 = MyDslValidator.valueResolver(_right_7);
          _switchResult = _valueResolver_14.equals(_valueResolver_15);
          break;
        default:
          _switchResult = false;
          break;
      }
    } else {
      _switchResult = false;
    }
    return _switchResult;
  }
  
  /**
   * Recursively resolve the type of an Expression
   */
  public static Value valueResolver(final Expression it) {
    try {
      Value _xblockexpression = null;
      {
        if ((it instanceof Value)) {
          return ((Value) it);
        }
        if ((it instanceof BinaryConstraint)) {
          Expression _left = ((BinaryConstraint)it).getLeft();
          final Value leftType = MyDslValidator.valueResolver(_left);
          Expression _right = ((BinaryConstraint)it).getRight();
          final Value rightType = MyDslValidator.valueResolver(_right);
          boolean _equals = leftType.equals(rightType);
          boolean _not = (!_equals);
          if (_not) {
            throw new Exception();
          }
          return leftType;
        }
        Value _xifexpression = null;
        if ((it instanceof Set)) {
          EList<Value> _has = ((Set) it).getHas();
          _xifexpression = _has.get(0);
        }
        _xblockexpression = _xifexpression;
      }
      return _xblockexpression;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  /**
   * Make sure that the expression of a unary constraint is a BooleanValue
   */
  protected static boolean _constraintUnary(final UnaryConstraint it) {
    Expression _expression = it.getExpression();
    Value _valueResolver = MyDslValidator.valueResolver(_expression);
    return (_valueResolver instanceof BooleanValue);
  }
  
  /**
   * Check that a set is not empty and all values have the same type
   */
  protected static boolean _constraintSet(final Set it) {
    boolean _and = false;
    EList<Value> _has = it.getHas();
    int _size = _has.size();
    boolean _greaterThan = (_size > 0);
    if (!_greaterThan) {
      _and = false;
    } else {
      EList<Value> _has_1 = it.getHas();
      final Function2<Boolean, Value, Boolean> _function = new Function2<Boolean, Value, Boolean>() {
        public Boolean apply(final Boolean b, final Value v) {
          boolean _and = false;
          if (!(b).booleanValue()) {
            _and = false;
          } else {
            Class<? extends Value> _class = v.getClass();
            EList<Value> _has = it.getHas();
            Value _get = _has.get(0);
            Class<? extends Value> _class_1 = _get.getClass();
            boolean _equals = Objects.equal(_class, _class_1);
            _and = _equals;
          }
          return Boolean.valueOf(_and);
        }
      };
      Boolean _fold = IterableExtensions.<Value, Boolean>fold(_has_1, Boolean.valueOf(true), _function);
      _and = (_fold).booleanValue();
    }
    return _and;
  }
  
  public static boolean constraint(final NamedElement it) {
    return _constraint(it);
  }
  
  public static boolean constraintParams(final Root it) {
    return _constraintParams(it);
  }
  
  public static boolean constraintAssignment(final Root it) {
    return _constraintAssignment(it);
  }
  
  public static boolean constraintOneAssignmentPerParameter(final Configuration it) {
    return _constraintOneAssignmentPerParameter(it);
  }
  
  public static boolean constraintBinary(final BinaryConstraint it) {
    return _constraintBinary(it);
  }
  
  public static boolean constraintUnary(final UnaryConstraint it) {
    return _constraintUnary(it);
  }
  
  public static boolean constraintSet(final Set it) {
    return _constraintSet(it);
  }
}
