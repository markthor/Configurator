/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.validation;

import java.util.Arrays;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  protected static boolean _constraint(final /* NamedElement */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field name is undefined for the type MyDslValidator"
      + "\nThe method or field name is undefined for the type MyDslValidator"
      + "\n!= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nisEmpty cannot be resolved"
      + "\n! cannot be resolved");
  }
  
  /**
   * Check for unique parameters in the root element.
   * If the sizes of the params and unique params are not the same
   * we have duplicate entries
   */
  protected static boolean _constraintParams(final /* Root */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nParameter cannot be resolved to a type."
      + "\nThe method or field expressions is undefined for the type MyDslValidator"
      + "\nThe method add is undefined for the type MyDslValidator"
      + "\nThe method name is undefined for the type MyDslValidator"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nfilter cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n== cannot be resolved"
      + "\nsize cannot be resolved");
  }
  
  /**
   * Check that the value of each assignment has the correct type according to the assigned type of the parameter
   */
  protected static boolean _constraintAssignment(final /* Root */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nParameter cannot be resolved to a type."
      + "\nTypeEnum cannot be resolved to a type."
      + "\nParameter cannot be resolved to a type."
      + "\nStringValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nBooleanValue cannot be resolved to a type."
      + "\nThe method or field expressions is undefined for the type MyDslValidator"
      + "\nThe method put is undefined for the type MyDslValidator"
      + "\nThe method or field configurators is undefined for the type MyDslValidator"
      + "\nThe method assignments is undefined for the type MyDslValidator"
      + "\nThe method assignments is undefined for the type MyDslValidator"
      + "\nThe method assignments is undefined for the type MyDslValidator"
      + "\nThe method parameter is undefined for the type MyDslValidator"
      + "\nThe method or field TypeEnum is undefined for the type MyDslValidator"
      + "\nThe method parameter is undefined for the type MyDslValidator"
      + "\nThe method or field TypeEnum is undefined for the type MyDslValidator"
      + "\nThe method parameter is undefined for the type MyDslValidator"
      + "\nThe method or field TypeEnum is undefined for the type MyDslValidator"
      + "\nType mismatch: cannot convert from Object to boolean"
      + "\nType mismatch: cannot convert from Object to boolean"
      + "\nType mismatch: cannot convert from Object to boolean"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nfilter cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nname cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nforall cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfilter cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nget cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nSTRING_TYPE cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nget cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nINTEGER_TYPE cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nget cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nBOOLEAN_TYPE cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n&& cannot be resolved");
  }
  
  /**
   * Check for unique parameters in a given configuration
   */
  protected static boolean _constraintOneAssignmentPerParameter(final /* Configuration */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field assignments is undefined for the type MyDslValidator"
      + "\nThe method add is undefined for the type MyDslValidator"
      + "\nThe method parameter is undefined for the type MyDslValidator"
      + "\nThe method or field assignments is undefined for the type MyDslValidator"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nfold cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n== cannot be resolved"
      + "\nsize cannot be resolved");
  }
  
  /**
   * Check that the types of BinaryConstraints are good
   */
  protected static boolean _constraintBinary(final /* BinaryConstraint */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nBooleanValue cannot be resolved to a type."
      + "\nBooleanValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nIntegerValue cannot be resolved to a type."
      + "\nThe method or field operator is undefined for the type MyDslValidator"
      + "\nThe method or field ADDITION is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field AND is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field EQUAL is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field GREATER is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field LESS is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field MULTIPLICATION is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field OR is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nThe method or field SUBSET is undefined for the type MyDslValidator"
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nequals cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nequals cannot be resolved");
  }
  
  /**
   * Recursively resolve the type of an Expression
   */
  public static /* Value */Object valueResolver(final /* Expression */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nValue cannot be resolved to a type."
      + "\nValue cannot be resolved to a type."
      + "\nBinaryConstraint cannot be resolved to a type."
      + "\nSet cannot be resolved to a type."
      + "\nSet cannot be resolved to a type."
      + "\nThe method or field left is undefined for the type MyDslValidator"
      + "\nThe method or field right is undefined for the type MyDslValidator"
      + "\nequals cannot be resolved"
      + "\n! cannot be resolved"
      + "\nhas cannot be resolved"
      + "\nget cannot be resolved");
  }
  
  /**
   * Make sure that the expression of a unary constraint is a BooleanValue
   */
  protected static boolean _constraintUnary(final /* UnaryConstraint */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nBooleanValue cannot be resolved to a type."
      + "\nThe method or field expression is undefined for the type MyDslValidator");
  }
  
  /**
   * Check that a set is not empty and all values have the same type
   */
  protected static boolean _constraintSet(final /* Set */Object it) {
    throw new Error("Unresolved compilation problems:"
      + "\nType mismatch: cannot convert from Object to boolean"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nhas cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nhas cannot be resolved"
      + "\nfold cannot be resolved"
      + "\nhas cannot be resolved"
      + "\nget cannot be resolved"
      + "\nclass cannot be resolved");
  }
  
  public static boolean constraint(final NamedElement it) {
    if (it != null) {
      return _constraint(it); else {
        throw new IllegalArgumentException("Unhandled parameter types: " +
          Arrays.<Object>asList(it).toString());
      }
    }
    
    public static boolean constraintParams(final Root it) {
      if (it != null) {
        return _constraintParams(it); else {
          throw new IllegalArgumentException("Unhandled parameter types: " +
            Arrays.<Object>asList(it).toString());
        }
      }
      
      public static boolean constraintAssignment(final Root it) {
        if (it != null) {
          return _constraintAssignment(it); else {
            throw new IllegalArgumentException("Unhandled parameter types: " +
              Arrays.<Object>asList(it).toString());
          }
        }
        
        public static boolean constraintOneAssignmentPerParameter(final Configuration it) {
          if (it != null) {
            return _constraintOneAssignmentPerParameter(it); else {
              throw new IllegalArgumentException("Unhandled parameter types: " +
                Arrays.<Object>asList(it).toString());
            }
          }
          
          public static boolean constraintBinary(final BinaryConstraint it) {
            if (it != null) {
              return _constraintBinary(it); else {
                throw new IllegalArgumentException("Unhandled parameter types: " +
                  Arrays.<Object>asList(it).toString());
              }
            }
            
            public static boolean constraintUnary(final UnaryConstraint it) {
              if (it != null) {
                return _constraintUnary(it); else {
                  throw new IllegalArgumentException("Unhandled parameter types: " +
                    Arrays.<Object>asList(it).toString());
                }
              }
              
              public static boolean constraintSet(final Set it) {
                if (it != null) {
                  return _constraintSet(it); else {
                    throw new IllegalArgumentException("Unhandled parameter types: " +
                      Arrays.<Object>asList(it).toString());
                  }
                }
              }
              