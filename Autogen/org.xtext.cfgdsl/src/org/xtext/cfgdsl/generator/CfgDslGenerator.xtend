/*
 * generated by Xtext
 */
package org.xtext.cfgdsl.generator

import ConfiguratorPackage.BinaryConstraint
import ConfiguratorPackage.Root
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import ConfiguratorPackage.UnaryConstraint

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class CfgDslGenerator implements IGenerator {
	
	def static compileToJava(Root it) {
		'''
			package cfgdsl;

			class Validator {
				
				public boolean validate(List<Assignment> assignments) {
					boolean valid = true;
					Map<String, Assignment> map = new HashMap<String, Assignment>();
					
					// Check the types of the assignments are well typed
					for(Assignment a : assignments) {
						valid = valid && (a.getParameter().getType().equals(a.getValue().getType()));
						map.put(a.getParameter().getName(), a);
					}
					
					for(Expression expr : «it.expressions.filter(typeof(BinaryConstraint))») {
						BinaryConstraint bc = (BinaryConstraint) expr;
						if(bc.getRoot()){
							if(validate(bc, map)){
								return true;
							} else{
								return false;
							}
						} else{
							return true;
						}
					}
					
					for(Expression expr : «it.expressions.filter(typeof(UnaryConstraint))») {
						UnaryConstraint uc = (UnaryConstraint) expr;
						if(uc.getRoot()){
							if(validate(uc, map)){
								return true;
							} else{
								return false;
							}
						} else{
							return true;
						}
					}
				}

				public Expression validate(BinaryConstraint bc, Map<String, Assignment> map){
					Expression left = getExpr(bc.getLeft(), map);
					Expression right = getExpr(bc.getRight(), map);
					
					ConfiguratorPackageFactoryImpl config = ConfiguratorPackageFactoryImpl.init();
					
					switch(bc.getOperator()) {
						case equals:			return left.equals(right);
						case less:				BooleanValue b = config.createBooleanValue();
												b.setValue(false);
												if(left instanceof IntegerValue && right instanceof IntegerValue)
													if(left.getValue() < right.getValue()){
														b.setValue(true);
													}
												return b;
						case greater:			BooleanValue b = config.createBooleanValue();
												b.setValue(false);
												if(left instanceof IntegerValue && right instanceof IntegerValue)
													if(left.getValue() > right.getValue()){
														b.setValue(true);
													}
						case addition:			if(bc.getRoot())
													BooleanValue b = config.createBooleanValue();
													b.setValue(false);
													return b;
												else if(left instanceof IntegerValue && right instanceof IntegerValue){
													IntegerValue i = config.createIntegerValue();
													i.setValue(left.getValue() + right.getValue())
													return i;
												} else
													BooleanValue b = config.createBooleanValue();
													b.setValue(false);
													return b;
						case multiplication:	if(bc.getRoot())
													BooleanValue b = config.createBooleanValue();
													b.setValue(false);
													return b;
												else if(left instanceof IntegerValue && right instanceof IntegerValue){
													IntegerValue i = config.createIntegerValue();
													i.setValue(left.getValue() * right.getValue())
													return i;
												} else
													BooleanValue b = config.createBooleanValue();
													b.setValue(false);
													return b;
						case subset:			BooleanValue b = config.createBooleanValue();
													b.setValue(false);
												if(right.getHas().contains(left)){
													b.setValue(true);
												}
												return b;
						case and:				BooleanValue b = config.createBooleanValue();
												b.setValue(false);
												if(left instanceof BooleanValue && right instanceof BooleanValue)
													if(left.getValue() && right.getValue()){
														b.setValue(true);
													}
												return b;
						case or:				BooleanValue b = config.createBooleanValue();
												b.setValue(false);
												if(left instanceof BooleanValue && right instanceof BooleanValue)
													if(left.getValue() || right.getValue()){
														b.setValue(true);
													}
												return b;
						}
				}
				
				
				private Expression getExpr(Expression expr, Map<String, Assignment> map) {
					Expression e;
					if(expr instanceof BinaryConstraint) {
						BinaryConstraint bc = (BinaryConstraint) expr;
						e = validate(bc, map);
						}
					} else if(expr instanceof UnaryConstraint) {
						UnaryConstraint uc = (UnaryConstraint) expr;
						e = validate(uc, map);
					} else if(expr instanceof Parameter) {
						Parameter p = (Parameter) expr;
						Assignment a = map.get(p.getName());
						Expression e = a.getValue();
					} else {
						Expression e = expr;
					}
					return e;
				}
				
				
				
				public BooleanValue validate(UnaryConstraint uc, Map<String, Assignment> map){
					ConfiguratorPackageFactoryImpl config = ConfiguratorPackageFactoryImpl.init();
					BooleanValue b = config.createBooleanValue();
					
					Expression expr = uc.getExpression;
					
					if(expr instanceof BinaryConstraint){
						BinaryConstraint bc = (BinaryConstraint) expr;
						BooleanValue value = validate(bc, map);
						b.setValue(!(value.getValue()));
					}
					else if(expr instanceof UnaryConstraint){
						UnaryConstraint uc = (UnaryConstraint) expr;
						
						BooleanValue value = validate(bc, map);
						b.setValue(!(value.getValue()));
					}
					else if(expr instanceof BooleanValue){
						BooleanValue value = (BooleanValue)expr;
						b.setValue(!(value.getValue()));
					}
					return b;
				}
			}
  		'''
	}
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	}
}
